Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwarePushbot.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\npackage org.firstinspires.ftc.teamcode;\r\n\r\nimport com.qualcomm.robotcore.hardware.DcMotor;\r\nimport com.qualcomm.robotcore.hardware.HardwareMap;\r\nimport com.qualcomm.robotcore.hardware.Servo;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\n/**\r\n * This is NOT an opmode.\r\n *\r\n * This class can be used to define all the specific hardware for a single robot.\r\n * In this case that robot is a Pushbot.\r\n * See PushbotTeleopTank_Iterative and others classes starting with \"Pushbot\" for usage examples.\r\n\r\n */\r\npublic class HardwarePushbot\r\n{\r\n    /* Public OpMode members. */\r\n    public DcMotor  FrontLeft   = null;\r\n    public DcMotor  FrontRight  = null;\r\n    public DcMotor  RearLeft   = null;\r\n    public DcMotor  RearRight  = null;\r\n\r\n    public static final double MID_SERVO       =  0.5 ;\r\n    public static final double ARM_UP_POWER    =  0.45 ;\r\n    public static final double ARM_DOWN_POWER  = -0.45 ;\r\n\r\n    /* local OpMode members. */\r\n    HardwareMap hwMap           =  null;\r\n    private ElapsedTime period  = new ElapsedTime();\r\n\r\n    /* Constructor */\r\n    public HardwarePushbot(){\r\n\r\n    }\r\n\r\n    /* Initialize standard Hardware interfaces */\r\n    public void init(HardwareMap ahwMap) {\r\n        // Save reference to Hardware map\r\n        hwMap = ahwMap;\r\n\r\n        // Define and Initialize Motors\r\n        FrontLeft  = hwMap.get(DcMotor.class, \"Front_left\");\r\n        FrontRight = hwMap.get(DcMotor.class, \"Front_right\");\r\n        RearLeft  = hwMap.get(DcMotor.class, \"Rear_left\");\r\n        RearRight = hwMap.get(DcMotor.class, \"Rear_right\");\r\n        FrontLeft.setDirection(DcMotor.Direction.FORWARD); // Set to REVERSE if using AndyMark motors\r\n        FrontRight.setDirection(DcMotor.Direction.REVERSE);// Set to FORWARD if using AndyMark motors\r\n        RearLeft.setDirection(DcMotor.Direction.FORWARD); // Set to REVERSE if using AndyMark motors\r\n        RearRight.setDirection(DcMotor.Direction.REVERSE);// Set to FORWARD if using AndyMark motors\r\n\r\n        // Set all motors to zero power\r\n        FrontLeft.setPower(0);\r\n        FrontRight.setPower(0);\r\n        RearLeft.setPower(0);\r\n        RearRight.setPower(0);\r\n\r\n        // Set all motors to run without encoders.\r\n        // May want to use RUN_USING_ENCODERS if encoders are installed.\r\n        FrontLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        FrontRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        RearLeft.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n        RearRight.setMode(DcMotor.RunMode.RUN_WITHOUT_ENCODER);\r\n\r\n    }\r\n }\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwarePushbot.java	(revision fd8bc9848098f5a04708a97ff67121c8255a1eda)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/HardwarePushbot.java	(date 1610488642031)
@@ -30,6 +30,7 @@
 package org.firstinspires.ftc.teamcode;
 
 import com.qualcomm.robotcore.hardware.DcMotor;
+import com.qualcomm.robotcore.hardware.DcMotorSimple;
 import com.qualcomm.robotcore.hardware.HardwareMap;
 import com.qualcomm.robotcore.hardware.Servo;
 import com.qualcomm.robotcore.util.ElapsedTime;
@@ -73,10 +74,10 @@
         FrontRight = hwMap.get(DcMotor.class, "Front_right");
         RearLeft  = hwMap.get(DcMotor.class, "Rear_left");
         RearRight = hwMap.get(DcMotor.class, "Rear_right");
-        FrontLeft.setDirection(DcMotor.Direction.FORWARD); // Set to REVERSE if using AndyMark motors
-        FrontRight.setDirection(DcMotor.Direction.REVERSE);// Set to FORWARD if using AndyMark motors
-        RearLeft.setDirection(DcMotor.Direction.FORWARD); // Set to REVERSE if using AndyMark motors
-        RearRight.setDirection(DcMotor.Direction.REVERSE);// Set to FORWARD if using AndyMark motors
+        FrontLeft.setDirection(DcMotor.Direction.REVERSE); // Set to REVERSE if using AndyMark motors
+        FrontRight.setDirection(DcMotor.Direction.FORWARD);// Set to FORWARD if using AndyMark motors
+        RearLeft.setDirection(DcMotor.Direction.REVERSE); // Set to REVERSE if using AndyMark motors
+        RearRight.setDirection(DcMotor.Direction.FORWARD);// Set to FORWARD if using AndyMark motors
 
         // Set all motors to zero power
         FrontLeft.setPower(0);
Index: TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Autonomous_LeftBlue.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.firstinspires.ftc.teamcode;\r\nimport com.qualcomm.hardware.rev.Rev2mDistanceSensor;\r\nimport com.qualcomm.robotcore.eventloop.opmode.Disabled;\r\nimport com.qualcomm.robotcore.eventloop.opmode.LinearOpMode;\r\nimport com.qualcomm.robotcore.eventloop.opmode.TeleOp;\r\nimport com.qualcomm.robotcore.hardware.DistanceSensor;\r\nimport org.firstinspires.ftc.robotcore.external.navigation.DistanceUnit;\r\nimport com.qualcomm.robotcore.util.ElapsedTime;\r\n\r\n@TeleOp(name = \"Sensor: REV2mDistance\", group = \"Sensor\")\r\n\r\n/**\r\n * This file uses the common Pushbot hardware class to define the drive on the robot.\r\n * The code is structured as a LinearOpMode.\r\n * The code assumes that you do NOT have encoders on the wheels,\r\n *   otherwise you would use: PushbotAutoDriveByEncoder;\r\n */\r\n\r\n@com.qualcomm.robotcore.eventloop.opmode.Autonomous(name=\"Pushbot: Auto Drive By Time\", group=\"Pushbot\")\r\n//@Disabled\r\npublic class Autonomous_LeftBlue extends LinearOpMode {\r\n    private DistanceSensor sensorRange;\r\n    /* Declare OpMode members. */\r\n    HardwarePushbot robot   = new HardwarePushbot();   // Use a Pushbot's hardware\r\n    private ElapsedTime     runtime = new ElapsedTime();\r\n\r\n\r\n    static final double     FORWARD_SPEED = 0.6;\r\n    static final double     TURN_SPEED    = 0.5;\r\n\r\n    @Override\r\n    public void runOpMode() {\r\n        sensorRange = hardwareMap.get(Rev2mDistanceSensor .class, \"sensor_range\");\r\n\r\n        //Initialize the drive system variables. The init() method of the hardware class does all the work here\r\n        robot.init(hardwareMap);\r\n\r\n        // Send telemetry message to signify robot waiting;\r\n        telemetry.addData(\"Status\", \"Ready to run\");    //\r\n        telemetry.update();\r\n\r\n        // Wait for the game to start (driver presses PLAY)\r\n        waitForStart();\r\n\r\n        // Step through each leg of the path, ensuring that the Auto mode has not been stopped along the way\r\n\r\n        // Step 1: Drive forward for .25 seconds to get off the line and move wobble thing.\r\n        robot.FrontLeft.setPower(FORWARD_SPEED);\r\n        robot.FrontRight.setPower(FORWARD_SPEED);\r\n        robot.RearLeft.setPower(FORWARD_SPEED);\r\n        robot.RearRight.setPower(FORWARD_SPEED);\r\n        runtime.reset();\r\n        while (opModeIsActive() && (runtime.seconds() < 0.5)) {\r\n            telemetry.addData(\"Path\", \"Part One: Moving forwards to get off wall.\", runtime.seconds());\r\n            telemetry.update();\r\n        }\r\n\r\n        // Step 2: Strafe right to check starter stack, temporarily leaving wobble thing.\r\n        robot.FrontLeft.setPower(FORWARD_SPEED);\r\n        robot.FrontRight.setPower(FORWARD_SPEED);\r\n        robot.RearLeft.setPower(-FORWARD_SPEED);\r\n        robot.RearRight.setPower(-FORWARD_SPEED);\r\n        while (opModeIsActive() && (runtime.seconds() < 0.25)) {\r\n            telemetry.addData(\"Path\", \"Part Two: Strafing to starter stack.\", runtime.seconds());\r\n            telemetry.update();\r\n        }\r\n\r\n        // Step 3: Check starter stack for how many rings there are, then store the distance in a variable\r\n        telemetry.addData(\"deviceName\",sensorRange.getDeviceName() );\r\n        telemetry.addData(\"Path\", \"Part Three: Checking starter stack height.\", runtime.seconds());\r\n        telemetry.addData(\"range\", String.format(\"%.01f in\", sensorRange.getDistance(DistanceUnit.INCH)));\r\n        telemetry.update();\r\n        //create variable\r\n        float stack = (float) sensorRange.getDistance(DistanceUnit.INCH);\r\n\r\n        // Step 4: Strafe back to the wobble thing.\r\n        robot.FrontLeft.setPower(-FORWARD_SPEED);\r\n        robot.FrontRight.setPower(-FORWARD_SPEED);\r\n        robot.RearLeft.setPower(FORWARD_SPEED);\r\n        robot.RearRight.setPower(FORWARD_SPEED);\r\n        while (opModeIsActive() && (runtime.seconds() < 0.25)) {\r\n            telemetry.addData(\"Path\", \"Part Four: Strafing back to wobble thing. \", runtime.seconds());\r\n            telemetry.update();\r\n        }\r\n\r\n        //Depending on what the height of the starter stack was, this will do different things\r\n        if (stack >=5.5) {\r\n            // Step 5: Turn towards target zone A.\r\n            robot.FrontLeft.setPower(TURN_SPEED);\r\n            robot.FrontRight.setPower(-TURN_SPEED);\r\n            robot.RearLeft.setPower(TURN_SPEED);\r\n            robot.RearRight.setPower(-TURN_SPEED);\r\n            while (opModeIsActive() && (runtime.seconds() < 0.25)) {\r\n                telemetry.addData(\"Path\", \"Part Five: Starter Stack 0- Turning towards target zone A. \", runtime.seconds());\r\n                telemetry.update();\r\n            }\r\n            // Step 6: Push wobble thing to target zone A.\r\n            robot.FrontLeft.setPower(FORWARD_SPEED);\r\n            robot.FrontRight.setPower(FORWARD_SPEED);\r\n            robot.RearLeft.setPower(FORWARD_SPEED);\r\n            robot.RearRight.setPower(FORWARD_SPEED);\r\n            runtime.reset();\r\n            while (opModeIsActive() && (runtime.seconds() < 0.75)) {\r\n                telemetry.addData(\"Path\", \"Part Six: Starter Stack 0- Pushing wobble thing to target zone A.\", runtime.seconds());\r\n                telemetry.update();\r\n            }\r\n        }\r\n         else if (stack >= 4.4 ) {\r\n            // Step 5: Turn towards target zone B.\r\n            robot.FrontLeft.setPower(-TURN_SPEED);\r\n            robot.FrontRight.setPower(TURN_SPEED);\r\n            robot.RearLeft.setPower(-TURN_SPEED);\r\n            robot.RearRight.setPower(TURN_SPEED);\r\n            while (opModeIsActive() && (runtime.seconds() < 0.15)) {\r\n                telemetry.addData(\"Path\", \"Part Six: Starter Stack 2- Turning towards target zone B. \", runtime.seconds());\r\n                telemetry.update();\r\n            }\r\n            // Step 6: Push wobble thing to target zone B.\r\n            robot.FrontLeft.setPower(FORWARD_SPEED);\r\n            robot.FrontRight.setPower(FORWARD_SPEED);\r\n            robot.RearLeft.setPower(FORWARD_SPEED);\r\n            robot.RearRight.setPower(FORWARD_SPEED);\r\n            runtime.reset();\r\n            while (opModeIsActive() && (runtime.seconds() < 3)) {\r\n                telemetry.addData(\"Path\", \"Part Six: Starter Stack 2- Pushing wobble thing to target zone B.\", runtime.seconds());\r\n                telemetry.update();\r\n            }\r\n         }\r\n         else {\r\n            // Step 5: Turn towards target zone C.\r\n            robot.FrontLeft.setPower(TURN_SPEED);\r\n            robot.FrontRight.setPower(-TURN_SPEED);\r\n            robot.RearLeft.setPower(TURN_SPEED);\r\n            robot.RearRight.setPower(-TURN_SPEED);\r\n            while (opModeIsActive() && (runtime.seconds() < 0.07)) {\r\n                telemetry.addData(\"Path\", \"Part Five: Starter Stack 4- Turning towards target zone C. \", runtime.seconds());\r\n                telemetry.update();\r\n            }\r\n            // Step 6: Push wobble thing to target zone C.\r\n            robot.FrontLeft.setPower(FORWARD_SPEED);\r\n            robot.FrontRight.setPower(FORWARD_SPEED);\r\n            robot.RearLeft.setPower(FORWARD_SPEED);\r\n            robot.RearRight.setPower(FORWARD_SPEED);\r\n            runtime.reset();\r\n            while (opModeIsActive() && (runtime.seconds() < 4.5)) {\r\n                telemetry.addData(\"Path\", \"Part Six: Starter Stack 4- Pushing wobble thing to target zone C.\", runtime.seconds());\r\n                telemetry.update();\r\n            }\r\n\r\n        }\r\n\r\n\r\n        // ...Last Step:  Stop.\r\n        robot.FrontLeft.setPower(0);\r\n        robot.FrontRight.setPower(0);\r\n        robot.RearLeft.setPower(0);\r\n        robot.RearRight.setPower(0);\r\n\r\n        telemetry.addData(\"Path\", \"Complete\");\r\n        telemetry.update();\r\n        sleep(1000);\r\n    }\r\n}\r\n    /*  // Backwards Code\r\n        robot.FrontLeft.setPower(-FORWARD_SPEED);\r\n        robot.FrontRight.setPower(-FORWARD_SPEED);\r\n        robot.RearLeft.setPower(-FORWARD_SPEED);\r\n        robot.RearRight.setPower(-FORWARD_SPEED);\r\n        runtime.reset();\r\n        while (opModeIsActive() && (runtime.seconds() < 1.0)) {\r\n            telemetry.addData(\"Path\", \"Leg 3: %2.5f S Elapsed\", runtime.seconds());\r\n            telemetry.update();\r\n        }  */\r\n       /* //Turning right Code if needed\r\n        robot.FrontLeft.setPower(-TURN_SPEED);\r\n        robot.FrontRight.setPower(TURN_SPEED);\r\n        robot.RearLeft.setPower(-TURN_SPEED);\r\n        robot.RearRight.setPower(TURN_SPEED);\r\n        runtime.reset();\r\n        while (opModeIsActive() && (runtime.seconds() < 1.3)) {\r\n            telemetry.addData(\"Path\", \"Leg 2: %2.5f S Elapsed\", runtime.seconds());\r\n            telemetry.update();\r\n        }  */\r\n\r\n\r\n/* Copyright (c) 2017 FIRST. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted (subject to the limitations in the disclaimer below) provided that\r\n * the following conditions are met:\r\n *\r\n * Redistributions of source code must retain the above copyright notice, this list\r\n * of conditions and the following disclaimer.\r\n *\r\n * Redistributions in binary form must reproduce the above copyright notice, this\r\n * list of conditions and the following disclaimer in the documentation and/or\r\n * other materials provided with the distribution.\r\n *\r\n * Neither the name of FIRST nor the names of its contributors may be used to endorse or\r\n * promote products derived from this software without specific prior written permission.\r\n *\r\n * NO EXPRESS OR IMPLIED LICENSES TO ANY PARTY'S PATENT RIGHTS ARE GRANTED BY THIS\r\n * LICENSE. THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\r\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,\r\n * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE\r\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\r\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\r\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\r\n * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\r\n * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\r\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Autonomous_LeftBlue.java	(revision fd8bc9848098f5a04708a97ff67121c8255a1eda)
+++ TeamCode/src/main/java/org/firstinspires/ftc/teamcode/Autonomous_LeftBlue.java	(date 1610488642047)
@@ -60,17 +60,21 @@
         robot.FrontRight.setPower(FORWARD_SPEED);
         robot.RearLeft.setPower(-FORWARD_SPEED);
         robot.RearRight.setPower(-FORWARD_SPEED);
+        runtime.reset();
         while (opModeIsActive() && (runtime.seconds() < 0.25)) {
             telemetry.addData("Path", "Part Two: Strafing to starter stack.", runtime.seconds());
             telemetry.update();
         }
 
         // Step 3: Check starter stack for how many rings there are, then store the distance in a variable
-        telemetry.addData("deviceName",sensorRange.getDeviceName() );
-        telemetry.addData("Path", "Part Three: Checking starter stack height.", runtime.seconds());
-        telemetry.addData("range", String.format("%.01f in", sensorRange.getDistance(DistanceUnit.INCH)));
-        telemetry.update();
-        //create variable
+        runtime.reset()
+        while (opModeIsActive() && (runtime.seconds() < 2)) {
+            telemetry.addData("deviceName",sensorRange.getDeviceName() );
+            telemetry.addData("Path", "Part Three: Checking starter stack height.", runtime.seconds());
+            telemetry.addData("range", String.format("%.01f in", sensorRange.getDistance(DistanceUnit.INCH)));
+            telemetry.update();
+
+        //Creates variable to store distance
         float stack = (float) sensorRange.getDistance(DistanceUnit.INCH);
 
         // Step 4: Strafe back to the wobble thing.
@@ -78,6 +82,7 @@
         robot.FrontRight.setPower(-FORWARD_SPEED);
         robot.RearLeft.setPower(FORWARD_SPEED);
         robot.RearRight.setPower(FORWARD_SPEED);
+        runtime.reset();
         while (opModeIsActive() && (runtime.seconds() < 0.25)) {
             telemetry.addData("Path", "Part Four: Strafing back to wobble thing. ", runtime.seconds());
             telemetry.update();
@@ -90,6 +95,7 @@
             robot.FrontRight.setPower(-TURN_SPEED);
             robot.RearLeft.setPower(TURN_SPEED);
             robot.RearRight.setPower(-TURN_SPEED);
+            runtime.reset();
             while (opModeIsActive() && (runtime.seconds() < 0.25)) {
                 telemetry.addData("Path", "Part Five: Starter Stack 0- Turning towards target zone A. ", runtime.seconds());
                 telemetry.update();
@@ -111,6 +117,7 @@
             robot.FrontRight.setPower(TURN_SPEED);
             robot.RearLeft.setPower(-TURN_SPEED);
             robot.RearRight.setPower(TURN_SPEED);
+            runtime.reset();
             while (opModeIsActive() && (runtime.seconds() < 0.15)) {
                 telemetry.addData("Path", "Part Six: Starter Stack 2- Turning towards target zone B. ", runtime.seconds());
                 telemetry.update();
@@ -132,6 +139,7 @@
             robot.FrontRight.setPower(-TURN_SPEED);
             robot.RearLeft.setPower(TURN_SPEED);
             robot.RearRight.setPower(-TURN_SPEED);
+            runtime.reset();
             while (opModeIsActive() && (runtime.seconds() < 0.07)) {
                 telemetry.addData("Path", "Part Five: Starter Stack 4- Turning towards target zone C. ", runtime.seconds());
                 telemetry.update();
